{"version":3,"file":"useChat.js","sources":["../node_modules/hono/dist/utils/cookie.js","../node_modules/hono/dist/client/utils.js","../node_modules/hono/dist/client/client.js","../src/hooks/useChat.ts"],"sourcesContent":["// src/utils/cookie.ts\nimport { decodeURIComponent_ } from \"./url.js\";\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await crypto.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  if (name && cookie.indexOf(name) === -1) {\n    return {};\n  }\n  const pairs = cookie.trim().split(\";\");\n  const parsedCookie = {};\n  for (let pairStr of pairs) {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      continue;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      continue;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);\n      if (name) {\n        break;\n      }\n    }\n  }\n  return parsedCookie;\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    throw new Error(\"__Secure- Cookie must have Secure attributes\");\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      throw new Error(\"__Host- Cookie must have Secure attributes\");\n    }\n    if (opt.path !== \"/\") {\n      throw new Error('__Host- Cookie must have Path attributes with \"/\"');\n    }\n    if (opt.domain) {\n      throw new Error(\"__Host- Cookie must not have Domain attributes\");\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${opt.maxAge | 0}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.priority) {\n    cookie += `; Priority=${opt.priority}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nexport {\n  parse,\n  parseSigned,\n  serialize,\n  serializeSigned\n};\n","// src/client/utils.ts\nvar mergePath = (base, path) => {\n  base = base.replace(/\\/+$/, \"\");\n  base = base + \"/\";\n  path = path.replace(/^\\/+/, \"\");\n  return base + path;\n};\nvar replaceUrlParam = (urlString, params) => {\n  for (const [k, v] of Object.entries(params)) {\n    const reg = new RegExp(\"/:\" + k + \"(?:{[^/]+})?\\\\??\");\n    urlString = urlString.replace(reg, v ? `/${v}` : \"\");\n  }\n  return urlString;\n};\nvar buildSearchParams = (query) => {\n  const searchParams = new URLSearchParams();\n  for (const [k, v] of Object.entries(query)) {\n    if (v === void 0) {\n      continue;\n    }\n    if (Array.isArray(v)) {\n      for (const v2 of v) {\n        searchParams.append(k, v2);\n      }\n    } else {\n      searchParams.set(k, v);\n    }\n  }\n  return searchParams;\n};\nvar replaceUrlProtocol = (urlString, protocol) => {\n  switch (protocol) {\n    case \"ws\":\n      return urlString.replace(/^http/, \"ws\");\n    case \"http\":\n      return urlString.replace(/^ws/, \"http\");\n  }\n};\nvar removeIndexString = (urlSting) => {\n  if (/^https?:\\/\\/[^\\/]+?\\/index$/.test(urlSting)) {\n    return urlSting.replace(/\\/index$/, \"/\");\n  }\n  return urlSting.replace(/\\/index$/, \"\");\n};\nfunction isObject(item) {\n  return typeof item === \"object\" && item !== null && !Array.isArray(item);\n}\nfunction deepMerge(target, source) {\n  if (!isObject(target) && !isObject(source)) {\n    return source;\n  }\n  const merged = { ...target };\n  for (const key in source) {\n    const value = source[key];\n    if (isObject(merged[key]) && isObject(value)) {\n      merged[key] = deepMerge(merged[key], value);\n    } else {\n      merged[key] = value;\n    }\n  }\n  return merged;\n}\nexport {\n  buildSearchParams,\n  deepMerge,\n  mergePath,\n  removeIndexString,\n  replaceUrlParam,\n  replaceUrlProtocol\n};\n","// src/client/client.ts\nimport { serialize } from \"../utils/cookie.js\";\nimport {\n  buildSearchParams,\n  deepMerge,\n  mergePath,\n  removeIndexString,\n  replaceUrlParam,\n  replaceUrlProtocol\n} from \"./utils.js\";\nvar createProxy = (callback, path) => {\n  const proxy = new Proxy(() => {\n  }, {\n    get(_obj, key) {\n      if (typeof key !== \"string\" || key === \"then\") {\n        return void 0;\n      }\n      return createProxy(callback, [...path, key]);\n    },\n    apply(_1, _2, args) {\n      return callback({\n        path,\n        args\n      });\n    }\n  });\n  return proxy;\n};\nvar ClientRequestImpl = class {\n  url;\n  method;\n  queryParams = void 0;\n  pathParams = {};\n  rBody;\n  cType = void 0;\n  constructor(url, method) {\n    this.url = url;\n    this.method = method;\n  }\n  fetch = async (args, opt) => {\n    if (args) {\n      if (args.query) {\n        this.queryParams = buildSearchParams(args.query);\n      }\n      if (args.form) {\n        const form = new FormData();\n        for (const [k, v] of Object.entries(args.form)) {\n          if (Array.isArray(v)) {\n            for (const v2 of v) {\n              form.append(k, v2);\n            }\n          } else {\n            form.append(k, v);\n          }\n        }\n        this.rBody = form;\n      }\n      if (args.json) {\n        this.rBody = JSON.stringify(args.json);\n        this.cType = \"application/json\";\n      }\n      if (args.param) {\n        this.pathParams = args.param;\n      }\n    }\n    let methodUpperCase = this.method.toUpperCase();\n    const headerValues = {\n      ...args?.header,\n      ...typeof opt?.headers === \"function\" ? await opt.headers() : opt?.headers\n    };\n    if (args?.cookie) {\n      const cookies = [];\n      for (const [key, value] of Object.entries(args.cookie)) {\n        cookies.push(serialize(key, value, { path: \"/\" }));\n      }\n      headerValues[\"Cookie\"] = cookies.join(\",\");\n    }\n    if (this.cType) {\n      headerValues[\"Content-Type\"] = this.cType;\n    }\n    const headers = new Headers(headerValues ?? void 0);\n    let url = this.url;\n    url = removeIndexString(url);\n    url = replaceUrlParam(url, this.pathParams);\n    if (this.queryParams) {\n      url = url + \"?\" + this.queryParams.toString();\n    }\n    methodUpperCase = this.method.toUpperCase();\n    const setBody = !(methodUpperCase === \"GET\" || methodUpperCase === \"HEAD\");\n    return (opt?.fetch || fetch)(url, {\n      body: setBody ? this.rBody : void 0,\n      method: methodUpperCase,\n      headers,\n      ...opt?.init\n    });\n  };\n};\nvar hc = (baseUrl, options) => createProxy(function proxyCallback(opts) {\n  const parts = [...opts.path];\n  const lastParts = parts.slice(-3).reverse();\n  if (lastParts[0] === \"toString\") {\n    if (lastParts[1] === \"name\") {\n      return lastParts[2] || \"\";\n    }\n    return proxyCallback.toString();\n  }\n  if (lastParts[0] === \"valueOf\") {\n    if (lastParts[1] === \"name\") {\n      return lastParts[2] || \"\";\n    }\n    return proxyCallback;\n  }\n  let method = \"\";\n  if (/^\\$/.test(lastParts[0])) {\n    const last = parts.pop();\n    if (last) {\n      method = last.replace(/^\\$/, \"\");\n    }\n  }\n  const path = parts.join(\"/\");\n  const url = mergePath(baseUrl, path);\n  if (method === \"url\") {\n    let result = url;\n    if (opts.args[0]) {\n      if (opts.args[0].param) {\n        result = replaceUrlParam(url, opts.args[0].param);\n      }\n      if (opts.args[0].query) {\n        result = result + \"?\" + buildSearchParams(opts.args[0].query).toString();\n      }\n    }\n    return new URL(result);\n  }\n  if (method === \"ws\") {\n    const webSocketUrl = replaceUrlProtocol(\n      opts.args[0] && opts.args[0].param ? replaceUrlParam(url, opts.args[0].param) : url,\n      \"ws\"\n    );\n    const targetUrl = new URL(webSocketUrl);\n    const queryParams = opts.args[0]?.query;\n    if (queryParams) {\n      Object.entries(queryParams).forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          value.forEach((item) => targetUrl.searchParams.append(key, item));\n        } else {\n          targetUrl.searchParams.set(key, value);\n        }\n      });\n    }\n    const establishWebSocket = (...args) => {\n      if (options?.webSocket !== void 0 && typeof options.webSocket === \"function\") {\n        return options.webSocket(...args);\n      }\n      return new WebSocket(...args);\n    };\n    return establishWebSocket(targetUrl.toString());\n  }\n  const req = new ClientRequestImpl(url, method);\n  if (method) {\n    options ??= {};\n    const args = deepMerge(options, { ...opts.args[1] });\n    return req.fetch(opts.args[0], args);\n  }\n  return req;\n}, []);\nexport {\n  hc\n};\n","import { hc } from 'hono/client'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport type { Message } from '#/components/MessageArea'\nimport type { AppType } from '#/server/app'\n\nconst client = hc<AppType>('/')\n\nconst NEAR_BOTTOM_THRESHOLD = 200 // 200px以内なら一番下とみなす\n\nexport function useChat() {\n  const messagesEndRef = useRef<HTMLDivElement>(null)\n  const scrollContainerRef = useRef<HTMLDivElement>(null)\n  const [shouldAutoScroll, setShouldAutoScroll] = useState(true)\n  const scrollTimeoutRef = useRef<number | null>(null)\n  const lastScrollTimeRef = useRef<number>(0)\n\n  // メッセージの状態管理\n  const [messages, setMessages] = useState<Message[]>([\n    {\n      id: (Date.now() + 1).toString(),\n      role: 'assistant',\n      content: 'こんにちは！\\n何かお手伝いできることはありますか？',\n      timestamp: new Date(),\n    },\n  ])\n\n  // ストリーミングの状態管理\n  const [streaming, setStreaming] = useState({\n    state: 'idle' as 'idle' | 'streaming',\n    text: '',\n    abortController: null as AbortController | null,\n    error: null as Error | null,\n  })\n\n  // メッセージ送信処理\n  const handleSendMessage = async (message: string) => {\n    const abortController = new AbortController()\n    setStreaming({\n      state: 'streaming',\n      text: '',\n      abortController,\n      error: null,\n    })\n\n    // ユーザーメッセージを追加\n    const userMessage: Message = {\n      id: Date.now().toString(),\n      role: 'user',\n      content: message,\n      timestamp: new Date(),\n    }\n\n    const newMessages = [...messages, userMessage]\n    setMessages(newMessages)\n    throttledScrollToBottom()\n\n    const response = await client.api.chat.$post(\n      {\n        json: {\n          messages: newMessages.slice(1).map((x) => ({\n            role: x.role,\n            content: x.content,\n          })),\n        },\n      },\n      { init: { signal: abortController.signal } },\n    )\n\n    if (response.ok) {\n      const reader = response.body?.getReader()\n      if (!reader) {\n        throw new Error('Failed to get reader from response body.')\n      }\n\n      const decoder = new TextDecoder('utf-8')\n      let chunks = ''\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) break\n        if (value) {\n          chunks += decoder.decode(value, { stream: true })\n          setStreaming((p) => ({ ...p, text: `${chunks}` }))\n        }\n      }\n\n      setMessages((prev) => [\n        ...prev,\n        {\n          id: (Date.now() + 1).toString(),\n          role: 'assistant',\n          content: chunks,\n          timestamp: new Date(),\n        },\n      ])\n    }\n\n    setStreaming({\n      state: 'idle',\n      text: '',\n      abortController: null,\n      error: null,\n    })\n  }\n\n  const handleSendMessageCancel = () => {\n    if (!streaming.abortController) {\n      return\n    }\n    streaming.abortController.abort()\n    if (streaming.text === '') {\n      // ストリーミング中に応答が返る前にキャンセルされた場合、メッセージは追加しない\n      messages.pop()\n    } else {\n      setMessages((prev) => [\n        ...prev,\n        {\n          id: (Date.now() + 1).toString(),\n          role: 'assistant',\n          content: streaming.text,\n          timestamp: new Date(),\n        },\n      ])\n    }\n    setStreaming({\n      state: 'idle',\n      text: '',\n      abortController: null,\n      error: null,\n    })\n  }\n\n  // スクロール位置を監視して自動スクロールするかどうかを判定\n  const handleScroll = () => {\n    if (!scrollContainerRef.current) return\n\n    const { scrollTop, scrollHeight, clientHeight } = scrollContainerRef.current\n    const isNearBottom = scrollHeight - scrollTop - clientHeight < NEAR_BOTTOM_THRESHOLD\n    setShouldAutoScroll(isNearBottom)\n  }\n\n  // 現在のスクロール位置が一番下付近かどうかをチェック\n  const isNearBottom = useCallback(() => {\n    if (!scrollContainerRef.current) return false\n    const { scrollTop, scrollHeight, clientHeight } = scrollContainerRef.current\n    return scrollHeight - scrollTop - clientHeight < NEAR_BOTTOM_THRESHOLD\n  }, [])\n\n  // スクロール処理をthrottleで間引く\n  const throttledScrollToBottom = useCallback(() => {\n    const now = Date.now()\n    const timeSinceLastScroll = now - lastScrollTimeRef.current\n\n    const executeScroll = () => {\n      // shouldAutoScrollとリアルタイムチェックの両方を確認\n      if (shouldAutoScroll && isNearBottom() && messagesEndRef.current) {\n        requestAnimationFrame(() => {\n          messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })\n          lastScrollTimeRef.current = Date.now()\n        })\n      }\n    }\n\n    // 100ms以内の連続スクロールは間引く\n    if (timeSinceLastScroll < 100) {\n      if (scrollTimeoutRef.current) {\n        clearTimeout(scrollTimeoutRef.current)\n      }\n      scrollTimeoutRef.current = window.setTimeout(executeScroll, 100)\n    } else {\n      executeScroll()\n      lastScrollTimeRef.current = now\n    }\n  }, [shouldAutoScroll, isNearBottom])\n\n  useEffect(() => {\n    // メッセージが更新されたときに、一番下にいる場合のみスクロール\n    throttledScrollToBottom()\n  }, [messages, streaming.text, throttledScrollToBottom])\n\n  // コンポーネントのアンマウント時にタイマーをクリア\n  useEffect(() => {\n    return () => {\n      if (scrollTimeoutRef.current) {\n        clearTimeout(scrollTimeoutRef.current)\n      }\n    }\n  }, [])\n\n  return {\n    messages,\n    messagesEndRef,\n    scrollContainerRef,\n    streaming,\n    handleSendMessage,\n    handleSendMessageCancel,\n    handleScroll,\n  }\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[0,1,2]}